\documentclass[a4paper]{scrartcl}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}  % Umlaute etc. verwenden
\usepackage[final]{graphicx}    % Grafiken einbinden
\usepackage{url}

\usepackage[pdftex,
    pdftitle={Hier soll der Titel hin},
    pdfauthor={Niklas Weimann}]{hyperref}


\setcounter{secnumdepth}{3}


\begin{document}

% Der Titel der Seminararbeit, sowie der Autor
\title{Hier soll der Titel hin}
\author{Niklas Weimann}
\date{\today}

\maketitle


\tableofcontents
\newpage



\section{Einleitung}
\textit{Was ist Fuchsia OS?}
"Pink + Purple == Fuchsia (a new Operating System)"\cite{GoogleLLC.} So beschreibt Google ein neues Betriebssystem, das auf Modularität und 
Was sind die Ziele?
\section{Zircon}
Fuchsia setzt auf den Microkernel Zircon, der vor seiner Umbenennung Magenta hieß. Zircon entstand aus Little Kernel, einem Projekt von Travis Geiselbrecht. Der Kernel wurde so designet, dass er sowohl auf IoT Hardware, als auch auf Desktop Computern eingesetzt werden kann. \cite{DaveAltavilla.30.Juni2019} Die Systemaufrufe, die Zircon zur Verfügung stellt, sind bis auf wenige Ausnahmen alle asynchron und blocken somit nicht den aufrufenden Thread, dies ermöglicht eine effizientere Abarbeitung der Jobs.
\subsection{Kernel Objects und System Calls}
Alle System Calls an den Zircon Kernel sind, bis auf wenige Ausnahmen asynchron und unterbrechbar, somit ist es möglich, dass der Thread während der Ausführung auf eine andere CPU migriert werden kann, was eine erhebliche Verbesserung der Performance zur folge hat.
Handles werden von System Calls zurückgegeben, falls diese ein Kernel Objekt erstellt haben (z.b. zx\_event\_create() + zx\_process\_create() + zx\_thread\_create()). Im Usermode ist dieses Handle eine 32 Bit Zahl, wobei die letzten 2 LSB bei validen Handles immer gesetzt sind und die Zahl 0 ein ungültiges Handle repräsentiert. Ein Handle hat nur für den jeweiligen Prozess eine Bedeutung, der es angefordert hat, in einem anderen Prozess kann dieses Handle auf ein anderes Kernel Objekt zeigen oder ungültig sein. Ein Prozess kann mehrere Handles haben, um auf das selbe Kernel Objekt zuzugreifen, wobei sich hierbei dann meist die jeweiligen Zugriffsrechte unterscheiden. Die Zugriffsrechte, die ein Handle auf ein Kernel Objekt hat, werden im Kernel gespeichert. Der Kernel hat für jedes Handle ein C++ Objekt, das erstens eine Referenz auf das Kernel Objekt hat, zweitens eine Liste mit allen Rechten die das Handle hat und drittens eine Referenz auf den Prozess, zu dem es gehört. Diese Zugriffsrechte können einschränken werden, indem mittels zx\_handle\_duplicate() \cite{https://fuchsia.dev/fuchsia-src/reference/syscalls/handle_replace} oder mittels zx\_handle\_replace() \cite{https://fuchsia.dev/fuchsia-src/reference/syscalls/handle_replace} ein neues Handle erstellt wird, dass eine Untermenge der Rechte des Ursprünglichen Handles besitzt.
Jedes Kernel Objekt kann eine Reihe an Outputs haben, sogenannte Signale. Jedes Signal kann nur eine ein Bit Information repräsentieren, wobei pro Objekt bis zu 32 Signale möglich sind. Diese Signale können mittels System Calls erwartet werden. Diese Signale repräsentieren sozusagen den Zustand, in dem sich das Kernel Objekt befindet.
Unter Linux hingegen gibt es keine Kernel Objekte und keine Handles. Systemcalls unter Linux sind relativ primitiv umgesetzt, es wird bei einem Systemcall nicht überprüft, ob ein Aufrufer die entsprechenden Rechte hat. Wenn ein Systemcall aufgerufen wird, dann werden die entsprechenden Daten, sowie der passende OP-Code einfach in die entsprechenden Register kopiert. Diese Implementierung ist zwar wesentlich einfacher umzusetzen, als das Handle Konzept von Zircon.
% Evtl. weiter ausarbeiten 
\subsection{Scheduling}
Bei Zircon läuft auf jeder CPU ein unabhängiger Scheduler, jedoch können die Scheduler untereinander kommunizieren, um Überlasten zu erkennen und Prozesse bei Bedarf auf eine andere CPU migrieren zu können, wobei Prozesse auch selbst angeben können, auf welcher CPU sie ausgeführt werden sollen.

Jeder Scheduler hält dabei für jede der 32 möglichen Prioritäten eine Warteschlange vor, in der die Prozesse auf die Ausführung warten, solange sie nicht den Status \"Blocked\" haben. Ein geblockter Prozess wird in eine Warteschlange für die entsprechende Ressource gepackt und nimmt nicht weiter am Scheduling teil, bis er entblockt wird. Nachdem die Ressource frei ist und der Prozess entblockt wurde, wird der Prozess direkt an den Anfang der entsprechenden Warteschlange für seine Prioriät eingefügt, sodass er sein komplettes Zeitintervall ausnutzen kann. Hat er das Zeitintervall aufgebraucht, wird er wieder ans Ende der Warteschlange eingefügt.

Welche Priorität ein Prozess bekommt hängt dabei von drei Faktoren ab, erstens gibt es eine Base Priorität, die frei gewählt werden kann, zweitens gibt es einen Prioritäts Boost und drittens eine Prioritätsvererbung.
Der Prioriätatsboost wird auf die Basis Priorität addiert und wird um eine Prioritätsstufe erhöht, wenn der Prozess entblockt wird, nachdem er auf eine Ressource gewartet hat, wohingegen die Prioritätsstufe um eines verringert wird, wenn der Prozess vor Ende seines zugewiesenen Zeitintervalls ein Resheduling anfordert oder wenn er das komplette Zeitintervall ohne Unterbrechung gerechnet hat.

Die Prioritätsvererbung wird eingesetzt, um Prozesse, die auf eine Ressource warten, die jedoch durch den aktuellen Prozess blockiert ist, schneller an die Ressource kommen zu lassen, da der aktuelle Prozess die Priorität des wartenden Prozesses erbt, wird der aktuelle Prozess häufiger aufgerufen und kann somit schneller terminieren.

Die Prioritätsberechnung ist wichtig, da Zircon im Gegensatz zu Linux auf einen Fairen Scheduling Algorithmus setzt, um die limitierte CPU Zeit auf die Prozesse zu verteilen. Die Warteschlangen für die einzelnen Prioritätsstufen werden im Round Robin Verfahren durchlaufen, somit ist sichergestellt, dass alle Threads (nach ausreichend langer Wartezeit) einmal in ausgeführt werden und nicht durch immer neu ankommende Threads mit einer sehr hohen Priorität verhungern.

Linux setzt in den aktuelleren Versionen auf einen Completly Fair Scheduling Algorithmus ähnlich zu dem von Zircon. Android hingegen setzt auf eine leicht abgewandelte des Linux Schedulers, hier werden die Prozesse in Gruppen aufgeteilt, um sicher zu stellen, dass Prozesse die im Vordergrund laufen häufiger CPU Zeit bekommen, als Prozesse, die im Hintergrund laufen. Dies wird im wesentlichen durch zwei Faktoren gesteuert, zum einen der Nice-Wert und zum anderen Cgroups.

Der Nice-Wert gibt an, wie nett ein Prozess zu den anderen Prozessen ist. Mit anderen Worten, je höher der Nice-Wert ist, um so seltener wird dieser Prozess vom Scheduler ausgewählt. Der Nice-Wert setzt also sozusagen die Priorität eines Prozesses nach unten ähnlich zu dem weiter oben erwähnten Prioritätsboost.

Cgroups (Control groups) sind ein von Linux bereitgestelltes System, um Prozesse zu Gruppieren und basierend auf diesen Gruppen das Scheduling zu beeinflussen. Cgroups werden genutzt, um die Benutzeroberfläche von Android möglichst performant zu halten. Die Prozesse werden also entsprechend ihrer Aufgabe klassifiziert, somit kann eine Cgroup, die Beispielsweise aus Background Tasks besteht, so beschränkt werden, dass sie Maximal 5\% der CPU-Zeit erhalten, damit kann sichergestellt werden, dass immer ausreichend CPU-Zeit verfügbar ist, um die Benutzeroberfläche performant wirken zu lassen.
\section{Komponenten v2}
\subsection{Komponenten Einführung}
Was ist eine Komponente?
Was ist das Komponenten Manifest?
\subsection{Komponenten Manager}
Was sind die Aufgaben des Komponenten Manager?
\subsection{Capabilities}
Was sind Capabilities (Service, Protocol, Directory, Storage)?
Was ist Capability Routing und wie funktioniert es?
\subsection{Vergleich zu Komponenten}
Welche Vorteile bietet es, dass alles eine Komponente ist im Gegensatz zu Linux (Android)?
\section{Treiber}
\subsection{Verwaltung und Zugriff}
Wie werden Treiber geladen?
Wie wird er Zugriff auf die Geräte ermöglicht?
\subsection{Vergleich Treiber}
Wie werden Treiber unter Linux (Android) verwaltet?
\section{Dateisystem}
\subsection{Komponentenbasierter Speicher}
Wie sind Dateisysteme und das Dateimanagement realisiert?
\subsection{Cloudunterstützung}
Was ist Ledger?
\subsection{Vergleich Filesystems}
Wie unterscheidet sich das Dateisystem von Linux (Andorid)?
\section{Zusammenfassung}
Grobe Zusammenfassung über die Unterschiede zu Linux (Android)

%***** Bibliographie  *****
%Die Literatur wird in einem eigenen Dokument im BibTeX Format erfasst: in diesem Fall: referenzen.bib
\bibliography{referenzen}
% --- Literaturstellen nummerieren
\bibliographystyle{plain}


\end{document}
