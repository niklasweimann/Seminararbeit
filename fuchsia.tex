\documentclass[a4paper]{scrartcl}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}  % Umlaute etc. verwenden
\usepackage[final]{graphicx}    % Grafiken einbinden
\usepackage{url}


\usepackage[pdftex,
    pdftitle={Hier soll der Titel hin},
    pdfauthor={Niklas Weimann}]{hyperref}


\setcounter{secnumdepth}{3}


\begin{document}

% Der Titel der Seminararbeit, sowie der Autor
\title{Hier soll der Titel hin}
\author{Niklas Weimann}
\date{\today}

\maketitle


\tableofcontents
\newpage



\section{Einleitung}
\textit{Was ist Fuchsia OS?}
"Pink + Purple == Fuchsia (a new Operating System)"\cite{GoogleLLC.} So beschreibt Google ein neues Betriebssystem, das auf Modularität und 
Was sind die Ziele?
\section{Zircon}
Fuchsia setzt auf den Microkernel Zircon, der vor seiner Umbenennung Magenta hieß. Zircon entstand aus Little Kernel, einem Projekt von Travis Geiselbrecht. Der Kernel wurde so designet, dass er sowohl auf IoT Hardware, als auch auf Desktop Computern eingesetzt werden kann. \cite{DaveAltavilla.30.Juni2019} Die Systemaufrufe, die Zircon zur Verfügung stellt, sind bis auf wenige Ausnahmen alle asynchron und blocken somit nicht den aufrufenden Thread, dies ermöglicht eine effizientere Abarbeitung der Jobs.
\subsection{Kernel Objects und System Calls}
Alle System Calls an den Zircon Kernel sind, bis auf wenige Ausnahmen asynchron und unterbrechbar, somit ist es möglich, dass der Thread während der Ausführung auf eine andere CPU migriert werden kann, was eine erhebliche Verbesserung der Performance zur folge hat.
Handles werden von System Calls zurückgegeben, falls diese ein Kernel Objekt erstellt haben (z.b. zx\_event\_create() + zx\_process\_create() + zx\_thread\_create()). Im Usermode ist dieses Handle eine 32 Bit Zahl, wobei die letzten 2 LSB bei validen Handles immer gesetzt sind und die Zahl 0 ein ungültiges Handle repräsentiert. Ein Handle hat nur für den jeweiligen Prozess eine Bedeutung, der es angefordert hat, in einem anderen Prozess kann dieses Handle auf ein anderes Kernel Objekt zeigen oder ungültig sein. Ein Prozess kann mehrere Handles haben, um auf das selbe Kernel Objekt zuzugreifen, wobei sich hierbei dann meist die jeweiligen Zugriffsrechte unterscheiden. Die Zugriffsrechte, die ein Handle auf ein Kernel Objekt hat, werden im Kernel gespeichert. Der Kernel hat für jedes Handle ein C++ Objekt, das erstens eine Referenz auf das Kernel Objekt hat, zweitens eine Liste mit allen Rechten die das Handle hat und drittens eine Referenz auf den Prozess, zu dem es gehört. Diese Zugriffsrechte können einschränken werden, indem mittels zx\_handle\_duplicate() \cite{https://fuchsia.dev/fuchsia-src/reference/syscalls/handle_replace} oder mittels zx\_handle\_replace() \cite{https://fuchsia.dev/fuchsia-src/reference/syscalls/handle_replace} ein neues Handle erstellt wird, dass eine Untermenge der Rechte des Ursprünglichen Handles besitzt.
Jedes Kernel Objekt kann eine Reihe an Outputs haben, sogenannte Signale. Jedes Signal kann nur eine ein Bit Information repräsentieren, wobei pro Objekt bis zu 32 Signale möglich sind. Diese Signale können mittels System Calls erwartet werden. Diese Signale repräsentieren sozusagen den Zustand, in dem sich das Kernel Objekt befindet.
Unter Linux hingegen gibt es keine Kernel Objekte und keine Handles. Systemcalls unter Linux sind relativ primitiv umgesetzt, es wird bei einem Systemcall nicht überprüft, ob ein Aufrufer die entsprechenden Rechte hat. Wenn ein Systemcall aufgerufen wird, dann werden die entsprechenden Daten, sowie der passende OP-Code einfach in die entsprechenden Register kopiert. Diese Implementierung ist zwar wesentlich einfacher umzusetzen, als das Handle Konzept von Zircon.
% Evtl. weiter ausarbeiten 
\subsection{Scheduling}
Bei Zircon läuft auf jeder CPU ein unabhängiger Scheduler, jedoch können die Scheduler untereinander kommunizieren, um Überlasten zu erkennen und Prozesse bei Bedarf auf eine andere CPU migrieren zu können, wobei Prozesse auch selbst angeben können, auf welcher CPU sie ausgeführt werden sollen.

Jeder Scheduler hält dabei für jede der 32 möglichen Prioritäten eine Warteschlange vor, in der die Prozesse auf die Ausführung warten, solange sie nicht den Status \"Blocked\" haben. Ein geblockter Prozess wird in eine Warteschlange für die entsprechende Ressource gepackt und nimmt nicht weiter am Scheduling teil, bis er entblockt wird. Nachdem die Ressource frei ist und der Prozess entblockt wurde, wird der Prozess direkt an den Anfang der entsprechenden Warteschlange für seine Prioriät eingefügt, sodass er sein komplettes Zeitintervall ausnutzen kann. Hat er das Zeitintervall aufgebraucht, wird er wieder ans Ende der Warteschlange eingefügt.

Welche Priorität ein Prozess bekommt hängt dabei von drei Faktoren ab, erstens gibt es eine Base Priorität, die frei gewählt werden kann, zweitens gibt es einen Prioritäts Boost und drittens eine Prioritätsvererbung.
Der Prioriätatsboost wird auf die Basis Priorität addiert und wird um eine Prioritätsstufe erhöht, wenn der Prozess entblockt wird, nachdem er auf eine Ressource gewartet hat, wohingegen die Prioritätsstufe um eines verringert wird, wenn der Prozess vor Ende seines zugewiesenen Zeitintervalls ein Resheduling anfordert oder wenn er das komplette Zeitintervall ohne Unterbrechung gerechnet hat.

Die Prioritätsvererbung wird eingesetzt, um Prozesse, die auf eine Ressource warten, die jedoch durch den aktuellen Prozess blockiert ist, schneller an die Ressource kommen zu lassen, da der aktuelle Prozess die Priorität des wartenden Prozesses erbt, wird der aktuelle Prozess häufiger aufgerufen und kann somit schneller terminieren.

Die Prioritätsberechnung ist wichtig, da Zircon im Gegensatz zu Linux auf einen Fairen Scheduling Algorithmus setzt, um die limitierte CPU Zeit auf die Prozesse zu verteilen. Die Warteschlangen für die einzelnen Prioritätsstufen werden im Round Robin Verfahren durchlaufen, somit ist sichergestellt, dass alle Threads (nach ausreichend langer Wartezeit) einmal in ausgeführt werden und nicht durch immer neu ankommende Threads mit einer sehr hohen Priorität verhungern.

Linux setzt in den aktuelleren Versionen auf einen Completly Fair Scheduling Algorithmus ähnlich zu dem von Zircon. Android hingegen setzt auf eine leicht abgewandelte des Linux Schedulers, hier werden die Prozesse in Gruppen aufgeteilt, um sicher zu stellen, dass Prozesse die im Vordergrund laufen häufiger CPU Zeit bekommen, als Prozesse, die im Hintergrund laufen. Dies wird im wesentlichen durch zwei Faktoren gesteuert, zum einen der Nice-Wert und zum anderen Cgroups.

Der Nice-Wert gibt an, wie nett ein Prozess zu den anderen Prozessen ist. Mit anderen Worten, je höher der Nice-Wert ist, um so seltener wird dieser Prozess vom Scheduler ausgewählt. Der Nice-Wert setzt also sozusagen die Priorität eines Prozesses nach unten ähnlich zu dem weiter oben erwähnten Prioritätsboost.

Cgroups (Control groups) sind ein von Linux bereitgestelltes System, um Prozesse zu Gruppieren und basierend auf diesen Gruppen das Scheduling zu beeinflussen. Cgroups werden genutzt, um die Benutzeroberfläche von Android möglichst performant zu halten. Die Prozesse werden also entsprechend ihrer Aufgabe klassifiziert, somit kann eine Cgroup, die Beispielsweise aus Background Tasks besteht, so beschränkt werden, dass sie Maximal 5\% der CPU-Zeit erhalten, damit kann sichergestellt werden, dass immer ausreichend CPU-Zeit verfügbar ist, um die Benutzeroberfläche performant wirken zu lassen.
\section{Komponenten v2}
Komponenten spielen bei Fuchsia eine wichtige Rolle, da nahe zu alle Programme in Fuchsia als Komponente angesehen werden.
\subsection{Komponenten Einführung}
\label{sec:Components}
"Eine Komponente ist ein hermetisches zusammensetzbares isoliertes Programm" \cite{FuCHSIADOCS}, so wird der Begriff "Komponente" in der Fuchsia Dokumentation definiert. Komponenten können in jeder beliebigen Sprache implementiert werden, für die es einen Component-Runner gibt. Ein Component-Runner ist dabei für jede Programmiersprache nötig, die für die Implementierung einer Komponente verwendet wurden. Dieser hat Kenntnis darüber, wie eine Komponente ausgeführt werden kann, während der Komponenten-Manager weiß, was ausgeführt werden soll.

Jede Komponente läuft während ihrer Ausführungszeit in einer Sandbox, sie ist also komplett von anderen Komponenten isoliert, dies ermöglicht es, dass jede Komponente einen eigenen Lebenszyklus, Zustand und Funktionen hat, somit ist auch sichergestellt, dass diese Komponente keine ungewollten Auswirkungen auf andere Komponenten haben kann. Stürzt beispielsweise eine Instanz einer  Komponente ab, so kann sie einfach durch eine neue Instanz der selben Komponente ersetzt werden, dies erhöht signifikant die Stabilität des Systems.

Einzelne Komponenten werden durch ein Komponenten Manifest definiert, dieses enthält alle wichtigen Informationen, die der Komponenten-Manager oder der jeweilige Komponenten-Runner brauchen, um die Komponente erfolgreich ausführen zu können. \cite{https://fuchsia.googlesource.com/fuchsia/+/master/sdk/fidl/fuchsia.sys2/decls/component_decl.fidl} 
Die Eigenschaften im Komponenten Manifest umfassen unter anderem die Programm Eigenschaft,  die Informationen für den Komponenten-Runner bereitstellt, damit dieser die Komponente erfolgreich starten zu können. Außerdem wird im Komponenten Manifest festgelegt, welchen Speicher (mehr dazu in Kapitel \ref{sec:Dateisystem}),  welche Capabilities die Komponente benötigt, anbietet und weiterleitet (mehr dazu in Kapitel \ref{sec:Capabilities}), sowie wie einige weitere Eigenschaften, auf die hier nicht genauer eingegangen werden soll.

Um die Interoperabilität zwischen den Komponenten und verschiedenen Programmiersprachen zu ermöglichen, wurde für Fuchsia die Fuchsia Interface Definition Language Sprache entwickelt (mehr dazu in Kapitel \ref{sec:FIDL}).

\subsection{FIDL}
\label{sec:FIDL}
Die Fuchsia Interface Definition Language oder kurz FIDL entkoppelt die Definition von Inter Prozess Kommunikation (IPC) und der jeweiligen Implementierung der IPC Mechanismen. Dies kann an einem einfachen Echo Service leicht verdeutlicht werden. Mit FIDL ist es möglich, dass eine Komponente in C++ implementiert wird und mit einer Komponente kommuniziert die in Dart implementiert wurde. Zum Zeitpunkt der Erstellung dieser Seminararbeit werden C++, C, Rust, Go und Dart unterstützt. Für jede unterstütze Sprache muss ein ein entsprechender Übersetzer existieren, der die in der FIDL Datei definierten Strukturen in der entsprechenden Sprache erstellt. Die Fuchsia Dokumentation widmet diesem Thema einen ganzen Abschnitt, der für jede Sprache definiert, wie die Strukturen aus Fuchsia in die entsprechende Sprache übersetzt werden.\cite{https://fuchsia.dev/fuchsia-src/reference/fidl/bindings/overview}

Eine Komponente implementiert meist das ServiceProvider Interface, dieser Service ermöglicht es, dass die Interface Definition alle Service innerhalb der Komponente, basierend auf dem Servicenamen, ausgegeben werden können. Ein Service ist dabei die Implementierung eines Service Interfaces, das wiederum einzelne Protokolle definieren kann. Zum Beispiel definiert der Netstack Service die Protokolle name\_lookup und socket\_provider (Siehe Beispiel unter \cite{https://fuchsia.dev/fuchsia-src/concepts/components/services?hl=en}).

Eine Anwendung kann einen Service nutzen, indem sie über die von Zircon zur IPC zur Verfügung gestellten Channels eine Verbindung zu diesem Service herstellt. Über diese Verbindung kann können dann Nachrichten übermittelt werden. Dabei spielt das FIDL wire Format eine wichtige Rolle, dieses definiert, wie Objekte encodiert werden müssen, um sie so zu Versenden, dass der Service, der den Protokoll aufgerufen hat, die Nachricht wieder korrekt dekodieren kann.

Jeder Aufruf einer durch den FIDL Übersetzer definierten Methode ist asynchron, deshalb haben alle Methoden, die durch einen FIDL Übersetzer erstellt werden keinen Rückgabe Typen. Die Rückgabe an einen aufrufenden Prozess läuft mittels Callback ab, der, neben den definierten Parametern, auch als Parameter mit in die Methode gegeben wird. Dieser Callback kann ein oder mehrere Parameter haben, dieses entsprechen den Rückgabe Werten, die im FIDL Interface definiert wurden (Genauere Informationen: \cite{https://fuchsia.googlesource.com/docs/+/ea2fce2874556205204d3ef70c60e25074dc7ffd/development/languages/fidl/tutorial.md}).

Unter Android gibt es eine ähnliche Interface Sprache, um die Kommunikation zwischen Clients und Services zu definieren. Unter Android heißt diese Sprache Android Interface Definition Language kurz AIDL, sie definiert, ähnlich wie bei FIDL, ein Interface zur Inter Prozess Kommunikation. Im Gegensatz zu FIDL setzt AIDL jedoch eins zu eins auf die Java Syntax für seine Interfaces, während Fuchsia eine C++ ähnliche Syntax verwendet und dabei mehr Strukturen unterstützt, als AIDL. Somit ist in AIDL im Gegensatz zu FIDL die Anzahl der Rückgabewerte auf eins begrenzt.
\subsection{Komponenten Manager}
Der Komponenten Manager stellt in Fuchsia eine zentrale Rolle da, dieser verwaltet das Zusammenspiel zwischen den Komponenten(\ref{sec:Components}). Der Komponenten Manager ist einer der ersten Prozesse, die beim Booten des Systems gestartet werden, dies ist erforderlich, da der Komponenten Manager alle Komponenten startet, die in Fuchsia verwendet werden.

Der Komponenten Manager ist neben der Verwaltung von einzelnen Komponenten auch der Mittler zwischen Komponenten, er stellt zum Beispiel die Verbindung zwischen zwei Komponenten her. Wenn eine Komponente den Service einer anderen Komponente nutzen möchte, sendet die erste Komponente eine Anfrage nach der Ziel Komponente basierend auf der URL der Komponente an den Komponenten Manager, dieser wiederum kennt die zugehörige Komponente zu dieser URL und stellt die Verbindung entsprechend her. Beim Verbindungsaufbau kann es vorkommen, dass eine Komponente bereits gestoppt und somit persistiert wurde, wenn dies der Fall ist, sorgt der Komponenten Manager dafür, dass die Komponente wieder gestartet und der Zustand wieder hergestellt wird. Als Mittler validiert der Komponenten Manager jeden Aufruf zu einem Service basierend auf den Rechten, die im Komponenten Manifest festgelegt wurden.

Aufgrund seiner zentralen Rolle in Fuchsia hat der Komponenten Manager eine privilegierte Rolle, da er viele Sicherheits- und Stabilitätsrelevante Entscheidungen treffen muss. Unterstützt wird der Komponenten Manager dabei durch die bereits oben erwähnten Runner, welche das Wissen über die Ausführung einer Komponente kapseln.

Neben diesen Aufgaben kümmert sich der Komponenten Manager auch drum, dass die Komponenten in einer validen Topologie organisiert sind. Dazu verwaltet der Manager eine Baumstruktur für die Abhängigkeit der Komponenten, die in einer Eltern-Kind-Beziehung zueinander stehen können. Außerdem wird ein Routing Graph für die Capabilities der Komponenten verwaltet, dieser stellt da, wie einzelne Instanzen von Komponenten Zugriff auf die Dienste von anderen Komponenten erhalten, dabei ist jedoch zu beachten, dass immer nur Eltern Komponenten Zugriff auf die Dienste ihrer Kinder bekommen und nicht umgekehrt.

Der Komponenten Manager kümmert sich außerdem um den Lebenszyklus von Komponenten. Dabei ist wichtig zu wissen, dass eine Komponenten Instanz sich in vier verschiedenen Zuständen befinden kann (Create, Start, Stop, Destroy).

\subsection{Capabilities}
\label{sec:Capabilities}
Was sind Capabilities (Service, Protocol, Directory, Storage)?
Was ist Capability Routing und wie funktioniert es?
\subsection{Vergleich zu Komponenten}
Welche Vorteile bietet es, dass alles eine Komponente ist im Gegensatz zu Linux (Android)?
\section{Treiber}
\subsection{Verwaltung und Zugriff}
Wie werden Treiber geladen?
Wie wird er Zugriff auf die Geräte ermöglicht?
\subsection{Vergleich Treiber}
Wie werden Treiber unter Linux (Android) verwaltet?
\section{Dateisystem}
\label{sec:Dateisystem}
\subsection{Komponentenbasierter Speicher}
Wie sind Dateisysteme und das Dateimanagement realisiert?
\subsection{Cloudunterstützung}
Was ist Ledger?
\subsection{Vergleich Filesystems}
Wie unterscheidet sich das Dateisystem von Linux (Andorid)?
\section{Zusammenfassung}
Grobe Zusammenfassung über die Unterschiede zu Linux (Android)

%***** Bibliographie  *****
%Die Literatur wird in einem eigenen Dokument im BibTeX Format erfasst: in diesem Fall: referenzen.bib
\bibliography{referenzen}
% --- Literaturstellen nummerieren
\bibliographystyle{plain}


\end{document}
